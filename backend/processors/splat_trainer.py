"""
3D Gaussian Splatting Training Automation Script
Automates the training process for 3D Gaussian Splatting models using datasets
generated by MeshBuilder software.

This script handles:
- Dataset validation and discovery
- Conda environment switching
- Training execution with configurable parameters
- Comprehensive logging and error handling
- Integration with MeshBuilder workflow
"""

import os
import sys
import logging
import subprocess
import time
import json
from pathlib import Path
from typing import Dict, Any, Optional, Callable, List
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("GaussianSplattingTrainer")


class GaussianSplattingTrainer:
    """
    Automated trainer for 3D Gaussian Splatting models
    
    Handles the complete training workflow from dataset validation
    to model training with proper environment management
    """
    
    def __init__(self, base_output_dir: str = "./output/"):
        """
        Initialize the Gaussian Splatting trainer
        
        Args:
            base_output_dir: Base directory containing project datasets
        """
        self.base_output_dir = Path(base_output_dir)
        self.project_root = Path(__file__).parent
        
        # Environment names
        self.meshbuilder_env = "meshbuilder"
        self.gaussian_splatting_env = "gaussian-splatting"
        
        # Training parameters validation
        self.valid_resolutions = [1000, 1200, 1600]
        self.min_iterations = 5000
        self.max_iterations = 30000
        
        logger.info("GaussianSplattingTrainer initialized")
    
    def validate_dataset(self, project_name: str) -> Dict[str, Any]:
        """
        Validate that a project dataset exists and is ready for training
        
        Args:
            project_name: Name of the project to validate
            
        Returns:
            Dictionary containing validation results and dataset info
        """
        dataset_path = self.base_output_dir / project_name / "dataset"
        
        validation_result = {
            "valid": False,
            "dataset_path": str(dataset_path),
            "project_name": project_name,
            "images_count": 0,
            "has_sparse_reconstruction": False,
            "errors": []
        }
        
        try:
            logger.info(f"Validating dataset for project: {project_name}")
            
            # Check if dataset directory exists
            if not dataset_path.exists():
                validation_result["errors"].append(f"Dataset directory not found: {dataset_path}")
                return validation_result
            
            # Check images directory
            images_dir = dataset_path / "images"
            if not images_dir.exists():
                validation_result["errors"].append("Images directory not found")
                return validation_result
            
            # Count image files
            image_extensions = {'.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.tif'}
            image_files = []
            for ext in image_extensions:
                image_files.extend(images_dir.glob(f"*{ext}"))
                image_files.extend(images_dir.glob(f"*{ext.upper()}"))
            
            validation_result["images_count"] = len(image_files)
            
            if len(image_files) == 0:
                validation_result["errors"].append("No image files found in images directory")
                return validation_result
            
            # Check sparse reconstruction
            sparse_dir = dataset_path / "sparse" / "0"
            if not sparse_dir.exists():
                validation_result["errors"].append("Sparse reconstruction directory not found (sparse/0/)")
                return validation_result
            
            # Check required COLMAP files
            required_files = ["cameras.bin", "images.bin", "points3D.bin"]
            missing_files = []
            
            for filename in required_files:
                file_path = sparse_dir / filename
                if not file_path.exists():
                    missing_files.append(filename)
                elif file_path.stat().st_size == 0:
                    missing_files.append(f"{filename} (empty)")
            
            if missing_files:
                validation_result["errors"].append(f"Missing or empty sparse files: {', '.join(missing_files)}")
                return validation_result
            
            validation_result["has_sparse_reconstruction"] = True
            validation_result["valid"] = True
            
            logger.info(f"Dataset validation successful:")
            logger.info(f"  - Images: {validation_result['images_count']}")
            logger.info(f"  - Sparse reconstruction: OK")
            logger.info(f"  - Dataset path: {dataset_path}")
            
        except Exception as e:
            validation_result["errors"].append(f"Validation error: {str(e)}")
            logger.error(f"Dataset validation failed: {e}")
        
        return validation_result
    
    def _run_conda_command(self, command: List[str], description: str, timeout: int = 30) -> bool:
        """
        Run a conda command with error handling
        
        Args:
            command: Command to execute
            description: Description for logging
            timeout: Command timeout in seconds
            
        Returns:
            True if successful, False otherwise
        """
        try:
            logger.info(f"Running: {description}")
            logger.debug(f"Command: {' '.join(command)}")
            
            # On Windows, we need to run conda commands through cmd
            if os.name == 'nt':
                command = ['cmd', '/c'] + command
            
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=timeout,
                shell=True if os.name == 'nt' else False
            )
            
            if result.returncode != 0:
                logger.error(f"{description} failed with return code {result.returncode}")
                logger.error(f"STDERR: {result.stderr}")
                return False
            
            logger.info(f"{description} completed successfully")
            return True
            
        except subprocess.TimeoutExpired:
            logger.error(f"{description} timed out after {timeout} seconds")
            return False
        except Exception as e:
            logger.error(f"{description} failed with exception: {e}")
            return False
    
    def switch_conda_environment(self, target_env: str) -> bool:
        """
        Switch to a specific conda environment
        
        Args:
            target_env: Name of the target conda environment
            
        Returns:
            True if successful, False otherwise
        """
        # First deactivate current environment
        deactivate_success = self._run_conda_command(
            ["conda", "deactivate"],
            f"Deactivating current conda environment",
            timeout=30
        )
        
        if not deactivate_success:
            logger.warning("Failed to deactivate current environment, continuing...")
        
        # Activate target environment
        activate_success = self._run_conda_command(
            ["conda", "activate", target_env],
            f"Activating conda environment: {target_env}",
            timeout=30
        )
        
        return activate_success
    
    def _validate_training_parameters(self, resolution: int, iterations: int) -> List[str]:
        """
        Validate training parameters
        
        Args:
            resolution: Training resolution
            iterations: Number of training iterations
            
        Returns:
            List of validation errors (empty if valid)
        """
        errors = []
        
        if resolution not in self.valid_resolutions:
            errors.append(f"Invalid resolution {resolution}. Valid options: {self.valid_resolutions}")
        
        if not (self.min_iterations <= iterations <= self.max_iterations):
            errors.append(f"Invalid iterations {iterations}. Must be between {self.min_iterations} and {self.max_iterations}")
        
        return errors
    
    def _run_training_command(self, dataset_path: str, output_path: str, 
                            resolution: int, iterations: int, timeout: int = 7200) -> bool:
        """
        Run the 3D Gaussian Splatting training command
        
        Args:
            dataset_path: Path to the COLMAP dataset
            output_path: Output directory for trained model
            resolution: Training resolution
            iterations: Number of training iterations
            timeout: Training timeout in seconds (default: 2 hours)
            
        Returns:
            True if training successful, False otherwise
        """
        # Construct training command
        cmd = [
            "python", "train.py",
            "-s", dataset_path,
            "-m", output_path,
            "--resolution", str(resolution),
            "--iterations", str(iterations)
        ]
        
        logger.info("Starting 3D Gaussian Splatting training")
        logger.info(f"Dataset: {dataset_path}")
        logger.info(f"Output: {output_path}")
        logger.info(f"Resolution: {resolution}")
        logger.info(f"Iterations: {iterations}")
        logger.info(f"Command: {' '.join(cmd)}")
        
        try:
            start_time = time.time()
            
            # Run training with real-time output
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True
            )
            
            # Stream output in real-time
            while True:
                output = process.stdout.readline()
                if output == '' and process.poll() is not None:
                    break
                if output:
                    # Log training output
                    logger.info(f"[TRAINING] {output.strip()}")
            
            # Wait for process to complete
            return_code = process.poll()
            elapsed_time = time.time() - start_time
            
            if return_code == 0:
                logger.info(f"Training completed successfully in {elapsed_time/60:.1f} minutes")
                return True
            else:
                logger.error(f"Training failed with return code {return_code}")
                return False
                
        except Exception as e:
            logger.error(f"Training failed with exception: {e}")
            return False
    
    def train_model(self, project_name: str, resolution: int = 1200, 
                   iterations: int = 15000, output_subdir: str = "Output_main",
                   callback: Optional[Callable] = None) -> Dict[str, Any]:
        """
        Train a 3D Gaussian Splatting model from a prepared dataset
        
        Args:
            project_name: Name of the project to train
            resolution: Training resolution (1000, 1200, or 1600)
            iterations: Number of training iterations (5000-30000)
            output_subdir: Output subdirectory name (default: "Output_main")
            callback: Optional progress callback function(message: str, progress: int)
            
        Returns:
            Dictionary containing training results and information
        """
        result = {
            "success": False,
            "project_name": project_name,
            "resolution": resolution,
            "iterations": iterations,
            "training_time": 0,
            "output_path": None,
            "errors": [],
            "dataset_info": {}
        }
        
        start_time = time.time()
        
        try:
            logger.info("=" * 80)
            logger.info("Starting 3D Gaussian Splatting Training Pipeline")
            logger.info(f"Project: {project_name}")
            logger.info(f"Resolution: {resolution}")
            logger.info(f"Iterations: {iterations}")
            logger.info("=" * 80)
            
            # Step 1: Validate training parameters
            if callback:
                callback("Validating training parameters", 5)
            
            param_errors = self._validate_training_parameters(resolution, iterations)
            if param_errors:
                result["errors"].extend(param_errors)
                return result
            
            # Step 2: Validate dataset
            if callback:
                callback("Validating dataset", 10)
            
            dataset_validation = self.validate_dataset(project_name)
            result["dataset_info"] = dataset_validation
            
            if not dataset_validation["valid"]:
                result["errors"].extend(dataset_validation["errors"])
                return result
            
            dataset_path = dataset_validation["dataset_path"]
            
            # Step 3: Set up output directory
            if callback:
                callback("Setting up output directory", 15)
            
            output_path = self.base_output_dir / project_name / output_subdir
            output_path.mkdir(parents=True, exist_ok=True)
            result["output_path"] = str(output_path)
            
            # Step 4: Switch to Gaussian Splatting environment
            if callback:
                callback("Switching to gaussian-splatting environment", 20)
            
            if not self.switch_conda_environment(self.gaussian_splatting_env):
                result["errors"].append("Failed to switch to gaussian-splatting environment")
                return result
            
            # Step 5: Run training
            if callback:
                callback("Running 3D Gaussian Splatting training", 25)
            
            training_success = self._run_training_command(
                dataset_path=dataset_path,
                output_path=str(output_path),
                resolution=resolution,
                iterations=iterations
            )
            
            if not training_success:
                result["errors"].append("Training execution failed")
                return result
            
            # Step 6: Switch back to MeshBuilder environment
            if callback:
                callback("Switching back to meshbuilder environment", 95)
            
            if not self.switch_conda_environment(self.meshbuilder_env):
                logger.warning("Failed to switch back to meshbuilder environment")
                # Don't fail the entire process for this
            
            # Training completed successfully
            result["success"] = True
            result["training_time"] = time.time() - start_time
            
            if callback:
                callback("Training completed successfully", 100)
            
            logger.info("=" * 80)
            logger.info("Training Pipeline Completed Successfully")
            logger.info(f"Training time: {result['training_time']/60:.1f} minutes")
            logger.info(f"Model output: {output_path}")
            logger.info("=" * 80)
            
        except Exception as e:
            result["errors"].append(f"Unexpected error: {str(e)}")
            logger.error(f"Training pipeline failed: {e}")
            
            # Attempt to switch back to meshbuilder environment on error
            try:
                self.switch_conda_environment(self.meshbuilder_env)
            except:
                pass
        
        finally:
            result["training_time"] = time.time() - start_time
        
        return result
    
    def list_available_projects(self) -> List[Dict[str, Any]]:
        """
        List all available projects with their dataset status
        
        Returns:
            List of project information dictionaries
        """
        projects = []
        
        if not self.base_output_dir.exists():
            logger.warning(f"Output directory does not exist: {self.base_output_dir}")
            return projects
        
        for project_dir in self.base_output_dir.iterdir():
            if project_dir.is_dir():
                project_name = project_dir.name
                validation = self.validate_dataset(project_name)
                
                project_info = {
                    "name": project_name,
                    "path": str(project_dir),
                    "dataset_valid": validation["valid"],
                    "images_count": validation.get("images_count", 0),
                    "has_sparse_reconstruction": validation.get("has_sparse_reconstruction", False)
                }
                
                projects.append(project_info)
        
        return projects
    
    def save_training_log(self, project_name: str, result: Dict[str, Any]) -> Path:
        """
        Save training results to a log file
        
        Args:
            project_name: Name of the project
            result: Training result dictionary
            
        Returns:
            Path to the saved log file
        """
        log_dir = self.base_output_dir / project_name / "logs"
        log_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        log_file = log_dir / f"training_log_{timestamp}.json"
        
        # Add timestamp to result
        result["timestamp"] = timestamp
        result["log_file"] = str(log_file)
        
        with open(log_file, 'w') as f:
            json.dump(result, f, indent=2)
        
        logger.info(f"Training log saved: {log_file}")
        return log_file


def test_trainer():
    """Test function for the Gaussian Splatting trainer"""
    try:
        trainer = GaussianSplattingTrainer()
        
        # Test basic functionality
        projects = trainer.list_available_projects()
        
        logger.info("GaussianSplattingTrainer test successful:")
        logger.info(f"  - Found {len(projects)} projects in output directory")
        logger.info("  - Trainer ready for use")
        logger.info("  - Environment switching configured")
        
        return True
    except Exception as e:
        logger.error(f"GaussianSplattingTrainer test failed: {e}")
        return False


if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="3D Gaussian Splatting Training Automation")
    parser.add_argument("project_name", help="Name of the project to train")
    parser.add_argument("--resolution", type=int, choices=[1000, 1200, 1600], 
                       default=1200, help="Training resolution")
    parser.add_argument("--iterations", type=int, default=15000,
                       help="Number of training iterations (5000-30000)")
    parser.add_argument("--output-dir", default="./output/",
                       help="Base output directory")
    parser.add_argument("--test", action="store_true",
                       help="Run test mode only")
    
    args = parser.parse_args()
    
    if args.test:
        success = test_trainer()
        if success:
            print("SUCCESS: GaussianSplattingTrainer is ready for use")
        else:
            print("FAILED: GaussianSplattingTrainer has issues")
            sys.exit(1)
    else:
        # Run training
        trainer = GaussianSplattingTrainer(args.output_dir)
        
        def progress_callback(message: str, progress: int):
            print(f"[{progress:3d}%] {message}")
        
        result = trainer.train_model(
            project_name=args.project_name,
            resolution=args.resolution,
            iterations=args.iterations,
            callback=progress_callback
        )
        
        # Save training log
        trainer.save_training_log(args.project_name, result)
        
        if result["success"]:
            print(f"\nSUCCESS: Training completed for project '{args.project_name}'")
            print(f"Training time: {result['training_time']/60:.1f} minutes")
            print(f"Model output: {result['output_path']}")
        else:
            print(f"\nFAILED: Training failed for project '{args.project_name}'")
            for error in result["errors"]:
                print(f"Error: {error}")
            sys.exit(1)